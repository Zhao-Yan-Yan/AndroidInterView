# TCP的三次握手和四次挥手，为什么不是两次握手？为什么挥手多一次呢？
> 客户端简称A，服务器端简称B

## 1.TCP建立连接需要三次握手

1. A向B表示想跟B进行连接（A发送syn包，A进入SYN_SENT状态）
2. B收到消息，表示我也准备好和你连接了（B收到syn包，需要确认syn包，并且自己也发送一个syn包，即发送了syn+ack包，B进入SYN_RECV状态）
3. A收到消息，并告诉B表示我收到你也准备连接的信号了（A收到syn+ack包，向服务器发送确认包ack，AB进入established状态）开始连接。

## 2.TCP断开连接需要四次挥手

1. A向B表示想跟B断开连接（A发送fin，进入FIN_WAIT_1状态）
2. B收到消息，但是B消息没发送完，只能告诉A我收到你的断开连接消息（B收到fin，发送ack，进入CLOSE_WAIT状态）
过一会，B数据发送完毕，告诉A，我可以跟你断开了（B发送fin，进入LAST_ACK状态）
3. A收到消息，告诉B，可以他断开（A收到fin，发送ack，B进入closed状态）

## 3.为什么挥手多一次
其实正常的断开和连接都是需要四次：

1. A发消息给B
2. B反馈给A表示正确收到消息
3. B发送消息给A
4. A反馈给B表示正确收到消息。

但是连接中，第二步和第三步是可以合并的，因为连接之前A和B是无联系的，所以没有其他情况需要处理。而断开的话，因为之前两端是正常连接状态，所以第二步的时候不能保证B之前的消息已经发送完毕，所以不能马上告诉A要断开的消息。这就是连接为什么可以少一步的原因。
## 4.为什么连接需要三次，而不是两次。
正常来说，我给你发消息，你告诉我能收到，不就代表我们之前通信是正常的吗？

简单回答就是，TCP是双向通信协议，如果两次握手，不能保证B发给A的消息正确到达。

TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。
TCP是怎么保证可靠传输的？

序列号和确认号。比如连接的一方发送一段80byte数据，会带上一个序列号，比如101。接收方收到数据，回复确认号181（180+1），这样下一次发送消息就会从181开始发送了。

所以握手过程中，比如A发送syn信号给B，初始序列号为120，那么B收到消息，回复ack消息，序列号为120+1。同时B发送syn信号给A，初始序列号为256，如果收不到A的回复消息，就会重发，否则丢失这个序列号，就无法正常完成后面的通信了。
这就是三次握手的原因。

# 签名认证
## 原理
非对称加密 公钥加密可以使用私钥解密 私钥加密可以使用公钥加密

如果不进行签名认证 可能会出现中间人伪造数据攻击

非对称加密虽然可以避免明文传输,及时中间人拿到公钥也无法解密的到原数据,但可以进行数据伪造

A -> B 发送 一条消息 使用B的公钥加密 B使用B的私钥进行解密 的到原数据

A -> B 发送一条消息 使用B的公钥加密 中间人C拿到B的公钥 并使用B的公钥进行数据伪造 发送给B B使用B的私钥进行解密 的到中间人C发送的数据

## 如何使用签名认证解决

A和B都拥有自己的私钥和公钥 并且互相持有对方的公钥

A使用B的公钥加密原数据得到密文数据  再使用A的私钥加密原数据得到签名数据 一起发送给B
B拿到数据后 使用B的私钥解密密文的到原数据 再使用A的公钥解密签名数据的到原数据 二者比较是否一致 确定数据来源是否安全

> 小问题 如果原数据过大 签名数据也会很大 影响传输效率

**如何解决**

hash摘要 在A进行签名加密时 先对原数据进行hash获取摘要 再对摘要进行签名  B验证时同样需要对解密后的数据进行hash 再与解密后的签名 比较验证
